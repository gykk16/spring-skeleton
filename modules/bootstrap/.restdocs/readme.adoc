= REST Docs 작성 가이드
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 3
:table-stripes: hover
:sectanchors:
:sectnums:
:sectnumlevels: 3

== 개요

본 프로젝트는 link:https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/[Spring REST Docs] 를 활용하여 API 문서를 생성합니다.
테스트 코드에서 API 스펙을 검증하고, 검증된 결과로 문서가 생성되므로 API 와 문서의 정합성이 보장됩니다.

=== 모듈 구조

[source]
----
modules/
├── test-support/                          # 테스트 유틸리티 모듈 (testFixtures)
│   └── src/testFixtures/
│       ├── kotlin/io/glory/testsupport/
│       │   └── restdocs/
│       │       ├── RestDocsSupport.kt     # REST Docs 테스트 베이스 클래스
│       │       ├── Field.kt              # DSL (type, means, example ...)
│       │       ├── DocsFieldType.kt      # 타입 정의 (NUMBER, STRING, ENUM ...)
│       │       ├── CustomResponseFieldsSnippet.kt  # 응답 코드 문서화
│       │       ├── DocumentFormatGenerator.kt      # 날짜/시간 포맷
│       │       └── common/               # 공통 응답 문서 테스트
│       │           ├── CommonResponseController.kt
│       │           ├── CommonResponseDocsTest.kt
│       │           └── CommonCodeDocsTest.kt
│       └── resources/org/springframework/restdocs/templates/
│           ├── request-fields.snippet     # 요청 필드 템플릿
│           ├── response-fields.snippet    # 응답 필드 템플릿
│           ├── query-parameters.snippet   # 쿼리 파라미터 템플릿
│           └── common-response-code-fields.snippet  # 응답 코드 템플릿
└── bootstrap/
    ├── .restdocs/asciidoc/               # AsciiDoc 문서 소스
    └── skeleton-api-app/src/test/        # API 문서 테스트
----

=== 문서 생성 흐름

[source]
----
테스트 실행 → 스니펫 생성 (.adoc) → AsciiDoc 문서에서 include → HTML 문서 생성
----

1. `RestDocsSupport` 를 상속받아 테스트 클래스를 작성합니다.
2. 테스트 실행 시 `build/generated-snippets/` 에 스니펫 파일이 생성됩니다.
3. `.restdocs/asciidoc/` 의 AsciiDoc 문서에서 생성된 스니펫을 `include` 합니다.


== 테스트 작성

=== 기본 구조

`RestDocsSupport` 를 상속받아 테스트 클래스를 작성합니다.

[source,kotlin]
----
class MyControllerDocsTest : RestDocsSupport() {

    private val myService: MyService = mock()

    override fun initController(): Any = MyController(myService)

    @Test
    fun `find item by id`(): Unit {
        // given
        val item = Item(id = 1, name = "Test Item")
        given(myService.findById(any())).willReturn(item)

        // when & then
        mockMvc.perform(get("/api/v1/items/{id}", 1))
            .andExpect(status().isOk)
            .andDo(
                restDocs.document(
                    pathParameters(
                        parameterWithName("id").description("Item ID"),
                    ),
                    responseFields(*responseCommonFieldsSubsection()),
                    dataResponseFields(
                        "id" type NUMBER means "Item ID",
                        "name" type STRING means "Item name",
                    ),
                )
            )
    }
}
----

**핵심 요소:**

- `initController()` - 테스트 대상 컨트롤러를 반환합니다. 의존성은 mock 처리합니다.
- `mockMvc` - 테스트용 MockMvc 인스턴스입니다. `RestDocsSupport` 에서 자동 설정됩니다.
- `restDocs` - `RestDocumentationResultHandler` 인스턴스입니다.

=== 스니펫 출력 경로

스니펫은 `{class-name}/{method-name}/` 패턴으로 생성됩니다.

[source]
----
build/generated-snippets/
└── my-controller-docs-test/
    └── find item by id/
        ├── http-request.adoc
        ├── http-response.adoc
        ├── path-parameters.adoc
        ├── response-fields.adoc
        └── response-fields-data.adoc
----


== Field DSL

Kotlin infix 함수를 활용한 DSL 로 필드를 선언합니다.

=== 기본 문법

[source,kotlin]
----
"필드경로" type 타입 means "설명"
----

=== 타입 (`DocsFieldType`)

[cols="1,2,2"]
|===
|타입|JSON 타입|용도

|`STRING`|String|문자열
|`NUMBER`|Number|숫자
|`BOOLEAN`|Boolean|참/거짓
|`OBJECT`|Object|객체
|`ARRAY`|Array|배열
|`DATE`|String|날짜 (`yyyy-MM-dd` 포맷 자동 설정)
|`DATETIME`|String|날짜/시간 (`yyyy-MM-dd'T'HH:mm:ss` 포맷 자동 설정)
|`ENUM(MyEnum::class)`|String|Enum (값 목록 자동 생성)
|`VARIES`|Varies|타입이 가변적인 경우
|`NULL`|Null|null
|===

=== 체이닝 옵션

[source,kotlin]
----
// 기본
"id" type NUMBER means "Item ID"

// 예시 값
"id" type NUMBER means "Item ID" example "12345"

// Optional 필드
"nickname" type STRING means "Nickname" isOptional true

// 기본값
"role" type STRING means "User role" withDefaultValue "USER"

// 포맷 지정
"phone" type STRING means "Phone number" formattedAs "010-XXXX-XXXX"

// Enum 타입 (값 목록 자동 생성)
"status" type ENUM(OrderStatus::class) means "Order status"

// 날짜/시간 타입 (포맷 자동 설정)
"createdAt" type DATETIME means "Created date"
"birthDate" type DATE means "Birth date"

// 복합 체이닝
"email" type STRING means "Email address" example "user@example.com" isOptional true
----

=== 배열 필드

[source,kotlin]
----
// 배열 내 객체 필드
"data[].id" type NUMBER means "Item ID"
"data[].name" type STRING means "Item name"

// 중첩 객체
"data.address.city" type STRING means "City"
"data.tags[]" type ARRAY means "Tag list"
----


== 공통 응답 문서화

=== 응답 전략 선택

프로젝트의 모든 API 는 `ApiResource<T>` 형식으로 응답합니다. 공통 필드(`status`, `meta`) 와 데이터 필드(`data`) 를 문서화하는 두 가지 전략이 있습니다.

[cols="1,2,2"]
|===
|전략|생성 파일|용도

|**단일 파일** (`responseCommonFields`)
|`response-fields.adoc` (모든 필드 포함)
|공통 + 데이터 필드를 하나의 테이블로 표시

|**분리 파일** (`responseCommonFieldsSubsection`)
|`response-fields.adoc` + `response-fields-data.adoc`
|공통 필드와 데이터 필드를 별도 테이블로 분리
|===

**분리 파일 전략을 권장합니다.** API 문서에서 데이터 필드만 별도로 표시할 수 있어 가독성이 좋습니다.

=== 전략 1: 단일 파일

[source,kotlin]
----
// 단건 응답 (data: Object)
restDocs.document(
    responseFields(
        *responseCommonFields(),
        *fields(
            "data.id" type NUMBER means "Item ID",
            "data.name" type STRING means "Item name",
        )
    )
)

// 목록 응답 (data: Array)
restDocs.document(
    responseFields(
        *responseArrayCommonFields(),
        *fields(
            "data[].id" type NUMBER means "Item ID",
            "data[].name" type STRING means "Item name",
        )
    )
)
----

=== 전략 2: 분리 파일 (권장)

[source,kotlin]
----
// 단건 응답 (data: Object)
restDocs.document(
    responseFields(*responseCommonFieldsSubsection()),
    dataResponseFields(
        "id" type NUMBER means "Item ID",
        "name" type STRING means "Item name",
    ),
)

// 목록 응답 (data: Array)
restDocs.document(
    responseFields(*responseArrayCommonFieldsSubsection()),
    dataResponseFields(
        "id" type NUMBER means "Item ID",
        "name" type STRING means "Item name",
    ),
)
----

NOTE: `dataResponseFields` 사용 시 필드 경로에 `data.` 접두사를 생략합니다.
`"id"` 로 작성하면 `data` 아래의 `id` 필드로 인식됩니다.

=== 공통 응답 헬퍼 목록

[cols="1,3"]
|===
|함수|설명

|`responseCommonFields()`
|단건 응답 공통 필드 (status, meta, data 를 prefix 포함하여 한 번에)

|`responseArrayCommonFields()`
|목록 응답 공통 필드

|`responseCommonFieldsSubsection()`
|단건 응답 공통 필드 (data 를 subsection 으로 분리)

|`responseArrayCommonFieldsSubsection()`
|목록 응답 공통 필드 (data 를 subsection 으로 분리)

|`dataResponseFields(vararg fields: Field)`
|`response-fields-data.adoc` 생성 (data 아래의 필드만)

|`statusCommonFormat()`
|status 필드 목록 (status, code, message)

|`metaCommonFormat()`
|meta 필드 목록 (traceId, appTraceId, responseTs, size)

|`pageCommonFormat()`
|pageInfo 필드 목록

|`noOffsetCommonFormat()`
|offsetInfo 필드 목록 (커서 기반 페이지네이션)

|`pageRequestFormat()`
|페이지 요청 파라미터 (page, size)
|===


== 요청 필드 / 파라미터 문서화

=== Request Body

[source,kotlin]
----
restDocs.document(
    requestFields(
        *fields(
            "name" type STRING means "Item name",
            "price" type NUMBER means "Price",
            "category" type ENUM(Category::class) means "Category",
        )
    )
)
----

=== Path Parameters

[source,kotlin]
----
restDocs.document(
    pathParameters(
        parameterWithName("id").description("Item ID"),
    )
)
----

=== Query Parameters

[source,kotlin]
----
restDocs.document(
    queryParameters(
        parameterWithName("keyword").description("Search keyword"),
        parameterWithName("page").optional().description("Page number"),
        parameterWithName("size").optional().description("Page size"),
    )
)
----

=== 페이지 요청 파라미터

페이지네이션 API 에서는 `pageRequestFormat()` 헬퍼를 활용할 수 있습니다.

[source,kotlin]
----
restDocs.document(
    queryParameters(
        parameterWithName("keyword").description("Search keyword"),
        *pageRequestFormat().toTypedArray(),
    )
)
----


== 페이지 응답 문서화

=== 일반 페이지 (Page)

[source,kotlin]
----
restDocs.document(
    responseFields(
        *responseArrayCommonFields(),
        subsectionWithPath("meta.pageInfo").type(JsonFieldType.OBJECT)
            .optional().description("페이지 정보"),
    ),
    responseFields(
        beneathPath("meta.pageInfo").withSubsectionId("data.page"),
        *pageCommonFormat().toTypedArray(),
    ),
    dataResponseFields(
        "id" type NUMBER means "Item ID",
        "name" type STRING means "Item name",
    ),
)
----

생성 파일:

- `response-fields.adoc` - 공통 필드 + `meta.pageInfo` subsection
- `response-fields-data.page.adoc` - pageInfo 필드 상세
- `response-fields-data.adoc` - data 필드 상세

=== No-Offset 페이지 (커서 기반)

[source,kotlin]
----
restDocs.document(
    responseFields(
        *responseArrayCommonFields(),
        subsectionWithPath("meta.offsetInfo").type(JsonFieldType.OBJECT)
            .optional().description("오프셋 정보 (커서 기반 페이지네이션)"),
    ),
    responseFields(
        beneathPath("meta.offsetInfo").withSubsectionId("data.no-offset"),
        *noOffsetCommonFormat().toTypedArray(),
    ),
    dataResponseFields(
        "id" type NUMBER means "Item ID",
        "name" type STRING means "Item name",
    ),
)
----

생성 파일:

- `response-fields.adoc` - 공통 필드 + `meta.offsetInfo` subsection
- `response-fields-data.no-offset.adoc` - offsetInfo 필드 상세
- `response-fields-data.adoc` - data 필드 상세


== 공통 응답 문서 테스트

공통 응답 형식과 응답 코드는 `test-support` 모듈의 testFixtures 에 정의되어 있습니다.
Bootstrap 앱에서 상속만 하면 공통 문서 스니펫이 자동으로 생성됩니다.

=== 설정 방법

Bootstrap 앱의 테스트 디렉토리에 다음 클래스를 추가합니다.

[source,kotlin]
----
package io.glory.myapp.docs.common

import io.glory.testsupport.restdocs.common.CommonResponseDocsTest as CommonResponseDocsTestBase

class CommonResponseDocsTest : CommonResponseDocsTestBase()
----

[source,kotlin]
----
package io.glory.myapp.docs.common

import io.glory.testsupport.restdocs.common.CommonCodeDocsTest as CommonCodeDocsTestBase

class CommonCodeDocsTest : CommonCodeDocsTestBase()
----

=== 생성되는 스니펫

`CommonResponseDocsTest` 실행 시:

[cols="2,3"]
|===
|스니펫|내용

|`common response format/response-fields.adoc`
|공통 응답 구조 (status, meta, data)

|`common response format/response-fields-data.status.adoc`
|status 필드 상세

|`common response format/response-fields-data.meta.adoc`
|meta 필드 상세

|`common page format/response-fields.adoc`
|페이지 응답 공통 필드

|`common page format/response-fields-data.page.adoc`
|pageInfo 필드 상세

|`common no offset page format/response-fields.adoc`
|No-Offset 페이지 응답 공통 필드

|`common no offset page format/response-fields-data.no-offset.adoc`
|offsetInfo 필드 상세
|===

`CommonCodeDocsTest` 실행 시:

[cols="2,3"]
|===
|스니펫|내용

|`response codes/common-response-code-fields-success.adoc`
|성공 응답 코드 목록

|`response codes/common-response-code-fields-error.adoc`
|에러 응답 코드 목록
|===


== AsciiDoc 문서 작성

=== 디렉토리 구조

[source]
----
modules/bootstrap/.restdocs/asciidoc/
├── .templates/
│   ├── template-api-req-res.adoc           # 공통 응답 형식 템플릿
│   ├── template-page-format.adoc           # 페이지 응답 형식 템플릿
│   └── template-no-offset-page-format.adoc # No-Offset 페이지 응답 형식 템플릿
└── {app-name}/
    └── {domain}/
        └── {domain}-v1.adoc                # API 문서
----

=== 문서 템플릿

새 API 문서를 작성할 때 아래 구조를 따릅니다.

[source,asciidoc]
-----
= My API
My API 연동 가이드
:snippets: ../../../../skeleton-api-app/build/generated-snippets/my-controller-docs-test
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 2
:table-stripes: hover
:sectanchors:
:sectnums:
:sectnumlevels: 2


= Overview

.본 문서는 My API 를 연동하기 위한 문서입니다.
[NOTE]
--
- API 에 대한 설명을 작성합니다.
--

[[api-format]]
\include::{docdir}/../../.templates/template-api-req-res.adoc[]

== APIs

[[find-all]]
=== 전체 조회

[NOTE]
--
- Item 목록을 전체 조회 합니다.
--

==== Http Request

\include::{snippets}/find all items/http-request.adoc[]

==== Http Response

\include::{snippets}/find all items/http-response.adoc[]

.Response Fields `data`
\include::{snippets}/find all items/response-fields-data.adoc[]
-----

**필수 속성:**

- `:snippets:` - API 테스트 스니펫 경로. 테스트 클래스 이름을 kebab-case 로 지정합니다. +
예) `TodoControllerDocsTest` -> `todo-controller-docs-test`

NOTE: 공통 응답 스니펫 경로(`:common-snippets:`)는 각 템플릿 파일 내에 정의되어 있으므로 API 문서에서 별도로 지정하지 않아도 됩니다.

=== 스니펫 include 패턴

[cols="2,3"]
|===
|스니펫|include 문법

|HTTP 요청
|`\include::{snippets}/{test-method}/http-request.adoc[]`

|HTTP 응답
|`\include::{snippets}/{test-method}/http-response.adoc[]`

|응답 필드 (공통 포함)
|`\include::{snippets}/{test-method}/response-fields.adoc[]`

|응답 필드 (데이터만)
|`\include::{snippets}/{test-method}/response-fields-data.adoc[]`

|Path Parameters
|`\include::{snippets}/{test-method}/path-parameters.adoc[]`

|Query Parameters
|`\include::{snippets}/{test-method}/query-parameters.adoc[]`

|Request Fields
|`\include::{snippets}/{test-method}/request-fields.adoc[]`

|페이지 정보
|`\include::{snippets}/{test-method}/response-fields-data.page.adoc[]`

|No-Offset 정보
|`\include::{snippets}/{test-method}/response-fields-data.no-offset.adoc[]`
|===

=== 공통 템플릿 include

`.templates/` 디렉토리의 템플릿은 공통 응답 형식 문서를 제공합니다.
각 템플릿은 `:common-snippets:` 속성을 자체적으로 정의하므로 API 문서에서 별도 설정이 필요 없습니다.

[cols="2,3"]
|===
|템플릿|include 문법

|공통 응답 형식 (status, meta, data)
|`\include::{docdir}/../../.templates/template-api-req-res.adoc[]`

|페이지 응답 형식 (pageInfo)
|`\include::{docdir}/../../.templates/template-page-format.adoc[]`

|No-Offset 페이지 응답 형식 (offsetInfo)
|`\include::{docdir}/../../.templates/template-no-offset-page-format.adoc[]`
|===

페이지네이션 API 문서에서는 필요에 따라 페이지 템플릿을 추가로 include 합니다.

[source,asciidoc]
-----
\include::{docdir}/../../.templates/template-api-req-res.adoc[]
\include::{docdir}/../../.templates/template-page-format.adoc[]
-----


== Mustache 템플릿

스니펫의 출력 형식은 Mustache 템플릿으로 커스터마이징됩니다.
템플릿 위치: `test-support/src/testFixtures/resources/org/springframework/restdocs/templates/`

=== 응답 필드 (`response-fields.snippet`)

[source,mustache]
----
|===
|Path|Type|Format|Description

\{{#fields}}

|\{{#tableCellContent}}`+\{{path}}+`\{{/tableCellContent}}
|\{{#tableCellContent}}\{{type}}\{{/tableCellContent}}
|\{{#tableCellContent}}\{{#format}}\{{format}}\{{/format}}\{{/tableCellContent}}
|\{{#tableCellContent}}\{{description}}\{{/tableCellContent}}

\{{/fields}}

|===
----

=== 요청 필드 (`request-fields.snippet`)

요청 필드 템플릿에는 `Required` 컬럼이 추가됩니다. `optional()` 이 설정되지 않은 필드는 `true` 로 표시됩니다.

=== 응답 코드 (`common-response-code-fields.snippet`)

응답 코드 문서는 Code, Http Status, Description 컬럼으로 구성됩니다.


== 전체 예시

`TodoControllerDocsTest` 를 참고하여 전체 흐름을 확인합니다.

[source,kotlin]
----
class TodoControllerDocsTest : RestDocsSupport() {

    private val todoService: TodoService = mock()

    override fun initController(): Any = TodoController(todoService)

    @Test
    fun `find all todos`(): Unit {
        // given
        val todos = listOf(
            Todo(id = 1, userId = 1, title = "delectus aut autem", completed = false),
            Todo(id = 2, userId = 1, title = "quis ut nam facilis", completed = true),
        )
        given(todoService.findAll()).willReturn(todos)

        // when & then
        mockMvc.perform(get("/api/v1/todos"))
            .andExpect(status().isOk)
            .andDo(
                restDocs.document(
                    responseFields(*responseArrayCommonFieldsSubsection()),
                    dataResponseFields(
                        "id" type NUMBER means "Todo ID" example "1",
                        "userId" type NUMBER means "User ID" example "1",
                        "title" type STRING means "Todo title",
                        "completed" type BOOLEAN means "Completion status",
                    ),
                )
            )
    }

    @Test
    fun `find todo by id`(): Unit {
        // given
        val todo = Todo(id = 1, userId = 1, title = "delectus aut autem", completed = false)
        given(todoService.findById(any())).willReturn(todo)

        // when & then
        mockMvc.perform(get("/api/v1/todos/{id}", 1))
            .andExpect(status().isOk)
            .andDo(
                restDocs.document(
                    pathParameters(
                        parameterWithName("id").description("Todo ID"),
                    ),
                    responseFields(*responseCommonFieldsSubsection()),
                    dataResponseFields(
                        "id" type NUMBER means "Todo ID" example "1",
                        "userId" type NUMBER means "User ID" example "1",
                        "title" type STRING means "Todo title",
                        "completed" type BOOLEAN means "Completion status",
                    ),
                )
            )
    }
}
----

=== Import 목록

테스트 작성 시 필요한 주요 import 입니다.

[source,kotlin]
----
// REST Docs DSL
import io.glory.testsupport.restdocs.DocsFieldType.*
import io.glory.testsupport.restdocs.RestDocsSupport
import io.glory.testsupport.restdocs.fields
import io.glory.testsupport.restdocs.type

// Spring REST Docs
import org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders.*
import org.springframework.restdocs.payload.PayloadDocumentation.*
import org.springframework.restdocs.request.RequestDocumentation.*

// Mocking
import org.mockito.kotlin.*

// Test
import org.junit.jupiter.api.Test
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status
----


== 빌드 및 실행

[source,bash]
----
# 전체 테스트 실행 (스니펫 생성)
./gradlew test

# 특정 테스트만 실행
./gradlew :modules:bootstrap:skeleton-api-app:test --tests "io.glory.skeletonapiapp.api.TodoControllerDocsTest"

# 공통 응답 문서 스니펫만 생성
./gradlew :modules:bootstrap:skeleton-api-app:test --tests "io.glory.skeletonapiapp.docs.common.*"
----
