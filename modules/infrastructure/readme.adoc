= Infrastructure Module
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 2
:sectnums:

== 개요

데이터베이스, 캐시, 외부 서비스와 연동합니다.

=== 주요 기능

|===
|기능 |설명

|HTTP Client
|RestClient + Feign 스타일 로깅

|Cache
|Caffeine (L1) + Redis (L2) 2단계 캐시

|Distributed Lock
|Redisson 기반 분산 락

|Async
|Virtual Thread + MDC 컨텍스트 전파

|Persistence
|JPA & QueryDSL
|===

== HTTP Client

=== HttpLoggingInterceptor

Feign 스타일 HTTP 요청/응답 로깅입니다.

[source,kotlin]
----
HttpLoggingInterceptor("TodoClient", Level.SIMPLE)
HttpLoggingInterceptor("TodoClient", Level.FULL)
----

==== 로그 레벨

|===
|레벨 |출력 내용

|`SIMPLE`
|요청/응답 라인 + END 요약

|`FULL`
|헤더 + 바디 포함
|===

==== 출력 예시 (SIMPLE)

[source]
----
[TodoClient#findById] ---> GET https://api.example.com/todos/1
[TodoClient#findById] ---> END (0-byte body)
[TodoClient#findById] <--- 200 OK (45ms)
[TodoClient#findById] <--- END (83-byte body)
----

=== HttpExchangeMethodAspect

`@HttpExchange` 메서드명을 캡처하는 AOP입니다.

* `HttpExchangeMethodContext`: ThreadLocal 기반 메서드명 전달
* Interceptor에서 실제 호출된 메서드명 로깅 가능

=== RestClientConfig

기본 RestClient Bean 설정입니다.

[source,kotlin]
----
@Bean
@Primary
fun defaultRestClient(restClientBuilder: RestClient.Builder): RestClient
----

== 캐시

=== CaffeineCacheManager (Primary)

로컬 인메모리 캐시입니다. 기본 캐시 매니저입니다.

|===
|설정 |값 |설명

|`maximumSize`
|200
|최대 캐시 항목 수

|`expireAfterWrite`
|30분
|쓰기 후 만료 시간

|`expireAfterAccess`
|10분
|마지막 접근 후 만료 시간
|===

=== RedisCacheManager

Redisson 기반 분산 캐시입니다. 인스턴스 간 캐시를 공유합니다.

|===
|캐시 이름 |TTL |유휴 시간 |용도

|`SHORT_LIVED`
|10분
|5분
|검색, 실시간 데이터

|`DEFAULT`
|30분
|10분
|일반 조회

|`MID_LIVED`
|1시간
|20분
|자주 변경되지 않는 데이터

|`LONG_LIVED`
|24시간
|4시간
|코드성 데이터, 설정
|===

==== 사용 예시

[source,kotlin]
----
import io.glory.infrastructure.cache.CacheConfig.Companion.DEFAULT

// 캐시 조회/저장
@Cacheable(cacheManager = "redisCacheManager", cacheNames = [DEFAULT], key = "#id")
fun findById(id: Long): User

// 캐시 삭제
@CacheEvict(cacheManager = "redisCacheManager", cacheNames = [DEFAULT], key = "#id")
fun update(id: Long): User
----

== Redis 함수

=== redisGet

캐시 조회 후 없으면 람다를 실행하여 저장합니다.

[source,kotlin]
----
val data = redisGet("cache-key", ttl = Duration.ofMinutes(5)) {
    repository.findData()
}
----

|===
|옵션 |설명

|`bypass`
|캐시 무시하고 직접 조회

|`force`
|캐시 강제 갱신
|===

=== redisSetAsync

캐시를 비동기로 저장합니다.

[source,kotlin]
----
redisSetAsync("cache-key") { computeData() }
----

=== redisDelete / redisUnlinkAsync

캐시를 삭제합니다.

[source,kotlin]
----
redisDelete("cache-key")           // 동기 삭제
redisUnlinkAsync("cache-key")      // 비동기 삭제
redisUnlinkByPatternAsync("key:*") // 패턴으로 삭제
----

== 분산 락

=== redisLock

Redisson 기반 분산 락입니다.

[source,kotlin]
----
redisLock("lock-key", waitTime = 3, leaseTime = 5) {
    // 임계 구역 (Critical Section)
}
----

|===
|파라미터 |기본값 |설명

|`waitTime`
|3초
|락 획득 대기 시간

|`leaseTime`
|5초
|락 유지 시간
|===

== 비동기

=== AsyncConfig

Virtual Thread 기반 비동기 실행 설정입니다.

|===
|설정 |값

|Thread prefix
|`async-vt-`

|TaskDecorator
|`ContextPropagatingTaskDecorator` (MDC 전파)
|===

=== MdcTaskDecorator

MDC 컨텍스트를 비동기 스레드로 전파합니다.

== 설정 방법

프로파일에 `infrastructure`를 포함하세요.

[source,yaml]
----
spring:
  profiles:
    include: infrastructure
----

== 주의 사항

[IMPORTANT]
====
**Redis Key Prefix 자동 적용**

모든 캐시/락 키에 prefix가 자동 추가됩니다.

* 형식: `glory:app:` + key (소문자 변환)
* 변경: `RedisConstants.REDIS_PREFIX`
====

[IMPORTANT]
====
**빈 컬렉션 캐시 방지**

캐시 오염 방지를 위해 빈 컬렉션은 캐시하지 않습니다.
====

[IMPORTANT]
====
**Docker Compose 자동 시작**

local/dev 환경에서 Redis가 자동 실행됩니다.
Bootstrap 모듈에 다음 의존성을 추가하세요.

[source,kotlin]
----
developmentOnly(rootProject.libs.spring.boot.docker.compose)
----
====
