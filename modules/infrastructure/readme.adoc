= Infrastructure Module
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 2
:sectnums:

== Overview

데이터베이스, 캐시, 외부 서비스 연동 인프라 모듈

* HTTP Client (RestClient + Logging)
* Cache (Caffeine + Redis)
* Distributed Lock (Redisson)
* Async (Virtual Thread)
* JPA & QueryDSL

== HTTP Client

=== HttpLoggingInterceptor

Feign 스타일 HTTP 요청/응답 로깅

[source,kotlin]
----
HttpLoggingInterceptor("TodoClient", Level.SIMPLE)
HttpLoggingInterceptor("TodoClient", Level.FULL)
----

==== Log Levels

|===
|Level |내용

|`SIMPLE`
|요청/응답 라인 + END summary

|`FULL`
|헤더 + 바디 포함
|===

==== 출력 예시 (SIMPLE)

[source]
----
[TodoClient#findById] ---> GET https://api.example.com/todos/1
[TodoClient#findById] ---> END (0-byte body)
[TodoClient#findById] <--- 200 OK (45ms)
[TodoClient#findById] <--- END (83-byte body)
----

=== HttpExchangeMethodAspect

`@HttpExchange` 인터페이스 메서드명 캡처 (AOP)

* `HttpExchangeMethodContext` - ThreadLocal 기반 메서드명 전달
* Interceptor에서 실제 메서드명 로깅 가능

=== RestClientConfig

기본 RestClient Bean 설정

[source,kotlin]
----
@Bean
@Primary
fun defaultRestClient(restClientBuilder: RestClient.Builder): RestClient
----

== Cache

=== CaffeineCacheManager (Primary)
로컬 인메모리 캐시

* `maximumSize`: 200
* `expireAfterWrite`: 30분
* `expireAfterAccess`: 10분

=== RedisCacheManager
분산 캐시 (Redisson)

|===
|Cache |TTL |maxIdleTime |용도

|`SHORT_LIVED`
|10분
|5분
|검색, 실시간 데이터

|`DEFAULT`
|30분
|10분
|일반 조회

|`MID_LIVED`
|1시간
|20분
|자주 변경되지 않는 데이터

|`LONG_LIVED`
|24시간
|4시간
|코드성 데이터, 설정
|===

==== 사용법

[source,kotlin]
----
import io.glory.infrastructure.cache.CacheConfig.Companion.DEFAULT

@Cacheable(cacheManager = "redisCacheManager", cacheNames = [DEFAULT], key = "#id")
fun findById(id: Long): User

@CacheEvict(cacheManager = "redisCacheManager", cacheNames = [DEFAULT], key = "#id")
fun update(id: Long): User
----

== Redis Functions

=== redisGet
캐시 조회 및 자동 저장

[source,kotlin]
----
val data = redisGet("cache-key", ttl = Duration.ofMinutes(5)) {
    repository.findData()
}

// bypass: 캐시 무시하고 직접 조회
// force: 캐시 강제 갱신
----

=== redisSetAsync
비동기 캐시 저장

[source,kotlin]
----
redisSetAsync("cache-key") { computeData() }
----

=== redisDelete / redisUnlinkAsync
캐시 삭제

[source,kotlin]
----
redisDelete("cache-key")           // 동기
redisUnlinkAsync("cache-key")      // 비동기
redisUnlinkByPatternAsync("key:*") // 패턴 삭제
----

== Distributed Lock

=== redisLock
분산 락

[source,kotlin]
----
redisLock("lock-key", waitTime = 3, leaseTime = 5) {
    // critical section
}
----

* `waitTime`: 락 획득 대기 시간 (default: 3초)
* `leaseTime`: 락 유지 시간 (default: 5초)

== Async

=== AsyncConfig
Virtual Thread 기반 비동기 실행

* Thread prefix: `async-vt-`
* `ContextPropagatingTaskDecorator` 적용 (MDC 전파)

=== MdcTaskDecorator
MDC 컨텍스트 전파용 TaskDecorator

== Important Notes

[IMPORTANT]
====
*Redis Key Prefix* - 모든 캐시/락 키는 자동으로 prefix 추가

`glory:app:` + key (소문자 변환)

변경: `RedisConstants.REDIS_PREFIX`
====

[IMPORTANT]
====
*Empty Collection* - 빈 컬렉션은 캐시하지 않음 (캐시 오염 방지)
====

[IMPORTANT]
====
*Docker Compose 자동 시작* - local/dev 환경에서 Redis 자동 실행

Bootstrap 모듈에 `developmentOnly` 의존성 필요:
[source,kotlin]
----
developmentOnly(rootProject.libs.spring.boot.docker.compose)
----
====

[NOTE]
====
*Profile 설정*

[source,yaml]
----
spring:
  profiles:
    include: infrastructure
----
====
