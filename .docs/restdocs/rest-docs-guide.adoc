= REST Docs 가이드
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 3
:sectnums:
:last-verified: 2026-02-06

이 문서는 프로젝트의 REST Docs 테스트 작성 방법과 API 문서 생성 전략을 설명합니다.

== 개요

REST Docs는 Spring REST Docs를 기반으로 API 테스트와 문서화를 통합하는 도구입니다. 프로젝트는 다음과 같은 특징을 제공합니다:

* **Type-safe Field DSL**: 필드 타입을 안전하게 정의하는 DSL
* **Field 빌더**: 필드 설명, 포맷, 예시, 옵션 여부 등을 체계적으로 정의
* **공통 응답 필드**: ApiResource 래퍼의 표준 필드 자동 처리
* **Subsection 전략**: 복잡한 응답을 논리적으로 분리하여 문서화
* **자동 포맷 적용**: DATE, DATETIME, ENUM 타입에 자동 포맷 적용

=== 핵심 이점

1. **테스트 기반 문서화**: API 테스트가 곧 문서화 소스
2. **항상 최신 상태**: 코드 변경 시 테스트를 업데이트하면 문서도 자동 갱신
3. **타입 안전성**: 컴파일 타임에 필드 정의 오류 감지
4. **일관된 API 응답**: ApiResource 표준 형식 강제

== 디렉토리 구조

프로젝트의 REST Docs 관련 파일 구조는 다음과 같습니다:

[source,text]
----
modules/
├── test-support/
│   └── src/testFixtures/kotlin/io/glory/testsupport/restdocs/
│       ├── RestDocsSupport.kt                    # 기본 클래스
│       ├── Field.kt                              # Field 빌더
│       ├── DocsFieldType.kt                      # 필드 타입 정의
│       ├── CustomResponseFieldsSnippet.kt        # 커스텀 스니펫
│       ├── DocumentFormatGenerator.kt            # 포맷 유틸
│       └── common/
│           ├── CommonResponseController.kt       # 테스트용 컨트롤러
│           ├── CommonResponseDocsTest.kt         # 공통 응답 테스트
│           └── CommonCodeDocsTest.kt             # 코드 테스트
│
├── bootstrap/
│   └── common-api-app/src/test/kotlin/io/glory/commonapiapp/docs/
│       └── HolidayControllerDocsTest.kt          # 실제 사용 예시
│
└── 생성된 문서/
    └── build/generated-snippets/
        └── {test-class-name}/
            ├── response-fields.adoc              # 응답 필드 문서
            ├── response-fields-data.adoc         # 데이터 필드 문서
            ├── request-fields.adoc               # 요청 필드 문서
            ├── path-parameters.adoc              # 경로 파라미터 문서
            └── ...
----

== 핵심 컴포넌트

=== RestDocsSupport

모든 REST Docs 테스트는 `RestDocsSupport`를 상속합니다. 이 클래스는 MockMvc 설정과 공통 필드 정의를 제공합니다.

==== 기본 구조

[source,kotlin]
----
@ExtendWith(RestDocumentationExtension::class)
abstract class RestDocsSupport {
    protected val jsonMapper: JsonMapper = JsonMapper.builder().build()
    protected val restDocs: RestDocumentationResultHandler = createRestDocumentationResultHandler()
    protected lateinit var mockMvc: MockMvc

    /**
     * 테스트할 컨트롤러 인스턴스 반환
     * 의존성은 모두 모킹되어야 함
     */
    protected abstract fun initController(): Any

    @BeforeEach
    fun setUpMockMvc(provider: RestDocumentationContextProvider) {
        // MockMvc 설정 (자동)
    }
}
----

==== 제공 메서드

[cols="2,3,4", options="header"]
|===
| 메서드 | 반환 타입 | 설명

| `resourceCommonFormat()`
| `List<FieldDescriptor>`
| status, meta, data(object) 필드

| `resourceArrayCommonFormat()`
| `List<FieldDescriptor>`
| status, meta, data(array) 필드

| `resourceStringCommonFormat()`
| `List<FieldDescriptor>`
| status, meta, data(string) 필드

| `statusCommonFormat()`
| `List<FieldDescriptor>`
| status 객체의 내부 필드

| `metaCommonFormat()`
| `List<FieldDescriptor>`
| meta 객체의 내부 필드

| `responseCommonFields()`
| `Array<FieldDescriptor>`
| 객체 응답용 공통 필드 (접두사 포함)

| `responseArrayCommonFields()`
| `Array<FieldDescriptor>`
| 배열 응답용 공통 필드 (접두사 포함)

| `responseStringCommonFields()`
| `Array<FieldDescriptor>`
| 문자열 응답용 공통 필드 (접두사 포함)

| `responseCommonFieldsSubsection()`
| `Array<FieldDescriptor>`
| Subsection 전략용 공통 필드

| `responseArrayCommonFieldsSubsection()`
| `Array<FieldDescriptor>`
| Subsection 전략용 배열 공통 필드

| `dataResponseFields(...)`
| `ResponseFieldsSnippet`
| 데이터 필드 subsection 생성
|===

=== DocsFieldType (필드 타입)

`DocsFieldType`은 sealed class로 필드의 데이터 타입을 안전하게 정의합니다.

[source,kotlin]
----
sealed class DocsFieldType(val type: JsonFieldType) {
    data object ARRAY : DocsFieldType(JsonFieldType.ARRAY)
    data object BOOLEAN : DocsFieldType(JsonFieldType.BOOLEAN)
    data object NUMBER : DocsFieldType(JsonFieldType.NUMBER)
    data object OBJECT : DocsFieldType(JsonFieldType.OBJECT)
    data object STRING : DocsFieldType(JsonFieldType.STRING)
    data object NULL : DocsFieldType(JsonFieldType.NULL)
    data object VARIES : DocsFieldType(JsonFieldType.VARIES)
    data object DATE : DocsFieldType(JsonFieldType.STRING)      // 자동 포맷 적용
    data object DATETIME : DocsFieldType(JsonFieldType.STRING)  // 자동 포맷 적용

    // ENUM: 열거형 값을 자동으로 포맷합니다
    class ENUM<T : Enum<T>>(
        val enums: Collection<T>,
    ) : DocsFieldType(JsonFieldType.STRING) {
        constructor(clazz: KClass<T>) : this(clazz.java.enumConstants.toList())
    }
}
----

==== 자동 포맷 적용

각 타입별로 자동으로 포맷이 적용됩니다:

[cols="1,2,3", options="header"]
|===
| 타입 | 포맷 | 예시

| `DATE`
| `yyyy-MM-dd`
| `2026-02-06`

| `DATETIME`
| `yyyy-MM-dd'T'HH:mm:ss`
| `2026-02-06T14:30:00`

| `ENUM`
| 열거형 값 나열
| `` `ACTIVE` / `INACTIVE` ``
|===

=== Field (필드 빌더)

`Field` 클래스는 infix 함수를 활용한 유연한 빌더 패턴을 제공합니다.

==== 프로퍼티

[cols="1,1,3", options="header"]
|===
| 프로퍼티 | 타입 | 설명

| `format`
| `String`
| 필드의 포맷 정보 (예: 날짜 형식)

| `sample`
| `String`
| 필드의 샘플 값

| `default`
| `String`
| 필드의 기본값
|===

==== Infix 함수

[cols="1,2,3", options="header"]
|===
| 함수 | 파라미터 | 설명

| `type`
| `DocsFieldType`
| 필드 타입 설정 (접두사: 생략)

| `means`
| `String`
| 필드 설명 설정

| `isOptional`
| `Boolean`
| 필드 선택 여부 설정

| `example`
| `String`
| 샘플 값 설정

| `formattedAs`
| `String`
| 포맷 정보 설정

| `withDefaultValue`
| `String`
| 기본값 설정

| `isIgnored`
| `Boolean`
| 문서에서 무시 설정

| `attributes`
| `Field.() -> Unit`
| 블록 내에서 프로퍼티 설정
|===

== DocsTest 작성 방법

===  Step 1: 테스트 클래스 생성

모든 DocsTest는 `RestDocsSupport`를 상속합니다.

[source,kotlin]
----
import io.glory.testsupport.restdocs.RestDocsSupport
import io.glory.testsupport.restdocs.DocsFieldType.*
import org.junit.jupiter.api.Test

class MyControllerDocsTest : RestDocsSupport() {

    private val myService: MyService = mock()

    override fun initController(): Any = MyController(myService)

    @Test
    fun `should document my endpoint`(): Unit {
        // 테스트 코드 작성
    }
}
----

=== Step 2: 모의 데이터 설정 (Given)

[source,kotlin]
----
@Test
fun `get holidays by year`(): Unit {
    // given - 서비스 동작 설정
    val holidays = listOf(
        Holiday(1L, LocalDate.of(2026, 2, 16), "설날"),
        Holiday(2L, LocalDate.of(2026, 2, 17), "설날"),
    )
    given(holidayService.findByYear(2026)).willReturn(holidays)

    // 이어서 when/then 작성...
}
----

=== Step 3: 요청 수행 (When)

[source,kotlin]
----
// when & then
mockMvc.perform(
    get("/api/holidays/{year}", 2026)
        .contentType(MediaType.APPLICATION_JSON)
)
    .andExpect(status().isOk)
    .andDo(
        restDocs.document(
            // 문서화 내용 작성
        )
    )
----

=== Step 4: 경로 파라미터 문서화

[source,kotlin]
----
import org.springframework.restdocs.request.RequestDocumentation.pathParameters
import org.springframework.restdocs.request.RequestDocumentation.parameterWithName

mockMvc.perform(get("/api/holidays/{year}", 2026))
    .andExpect(status().isOk)
    .andDo(
        restDocs.document(
            pathParameters(
                parameterWithName("year").description("조회할 연도"),
            ),
            // ...
        )
    )
----

=== Step 5: 요청 필드 문서화

[source,kotlin]
----
import org.springframework.restdocs.payload.PayloadDocumentation.requestFields
import io.glory.testsupport.restdocs.fields

mockMvc.perform(
    post("/api/holidays")
        .contentType(MediaType.APPLICATION_JSON)
        .content(request)
)
    .andExpect(status().isOk)
    .andDo(
        restDocs.document(
            requestFields(
                *fields(
                    "holidayDate" type DATE means "공휴일 날짜",
                    "name" type STRING means "공휴일 이름",
                )
            ),
            // ...
        )
    )
----

=== Step 6: 응답 필드 문서화

단순한 응답(모든 필드를 한 곳에 문서화)인 경우:

[source,kotlin]
----
import org.springframework.restdocs.payload.PayloadDocumentation.responseFields
import io.glory.testsupport.restdocs.RestDocsSupport.Companion.responseCommonFields

mockMvc.perform(delete("/api/holidays/{id}", 1L))
    .andExpect(status().isOk)
    .andDo(
        restDocs.document(
            pathParameters(
                parameterWithName("id").description("삭제할 공휴일 ID"),
            ),
            responseFields(*responseStringCommonFields()),
        )
    )
----

== Field DSL 사용법

=== 기본 패턴

가장 단순한 필드 정의:

[source,kotlin]
----
"data.id" type NUMBER means "사용자 ID"
"data.name" type STRING means "사용자 이름"
"data.createdAt" type DATETIME means "생성 일시"
----

=== 선택적 필드 표시

[source,kotlin]
----
"data.nickname" type STRING means "별명" isOptional true
"data.phone" type STRING means "전화번호" isOptional true
----

=== 샘플 값 추가

[source,kotlin]
----
"data.email" type STRING means "이메일" example "user@example.com"
"data.age" type NUMBER means "나이" example "25"
----

=== 기본값 설정

[source,kotlin]
----
"data.status" type STRING means "상태" example "ACTIVE" withDefaultValue "PENDING"
"data.role" type STRING means "역할" example "USER" withDefaultValue "USER"
----

=== 날짜/시간 타입 (자동 포맷)

[source,kotlin]
----
// DATE - 자동으로 yyyy-MM-dd 포맷 적용
"data.birthday" type DATE means "생년월일"

// DATETIME - 자동으로 yyyy-MM-dd'T'HH:mm:ss 포맷 적용
"data.createdAt" type DATETIME means "생성 일시"
----

=== 열거형 타입 (자동 포맷)

[source,kotlin]
----
// ENUM - 열거형 값을 자동으로 나열
"data.status" type ENUM(Status::class) means "주문 상태"
// 출력: `PENDING` / `PROCESSING` / `COMPLETED` / `CANCELLED`

// 특정 값만 포함
"data.priority" type ENUM(listOf(Priority.HIGH, Priority.MEDIUM)) means "우선순위"
----

=== 배열 필드

[source,kotlin]
----
"data.tags" type ARRAY means "태그 목록"
"data.items[].id" type NUMBER means "항목 ID"
"data.items[].name" type STRING means "항목 이름"
----

=== 객체 필드

[source,kotlin]
----
"data.user" type OBJECT means "사용자 정보"
"data.user.id" type NUMBER means "사용자 ID"
"data.user.name" type STRING means "사용자 이름"
----

=== 복합 설정

[source,kotlin]
----
"data.discount" type NUMBER means "할인 금액"
    example "10000"
    withDefaultValue "0"
    isOptional true

// 또는 attributes 블록 사용
"data.status" type STRING means "상태" attributes {
    sample = "ACTIVE"
    default = "PENDING"
    format = "ACTIVE / PENDING / INACTIVE"
}
----

== 공통 응답 패턴

=== 전략 1: responseCommonFields() - 전체 필드 한 곳에 문서화

가장 간단하고 직관적인 방식입니다. 모든 필드를 responseFields에서 함께 정의합니다.

==== 사용 시나리오

* 응답 필드가 많지 않은 경우
* 구조가 단순한 경우
* 빠르게 문서화해야 하는 경우

==== 객체 응답 예시

[source,kotlin]
----
@Test
fun `get user`(): Unit {
    // given
    val user = User(1L, "홍길동", "hong@example.com")
    given(userService.findById(1L)).willReturn(user)

    // when & then
    mockMvc.perform(get("/api/users/{id}", 1L))
        .andExpect(status().isOk)
        .andDo(
            restDocs.document(
                pathParameters(
                    parameterWithName("id").description("사용자 ID"),
                ),
                responseFields(
                    *responseCommonFields(),    // status, meta, data 공통 필드
                    *fields(
                        "data.id" type NUMBER means "사용자 ID",
                        "data.name" type STRING means "사용자 이름",
                        "data.email" type STRING means "이메일",
                    )
                )
            )
        )
}
----

생성된 문서: 단일 `response-fields.adoc` 파일

==== 배열 응답 예시

[source,kotlin]
----
@Test
fun `get holidays by year`(): Unit {
    // given
    val holidays = listOf(
        Holiday(1L, LocalDate.of(2026, 2, 16), "설날"),
        Holiday(2L, LocalDate.of(2026, 2, 17), "설날"),
    )
    given(holidayService.findByYear(2026)).willReturn(holidays)

    // when & then
    mockMvc.perform(get("/api/holidays/{year}", 2026))
        .andExpect(status().isOk)
        .andDo(
            restDocs.document(
                pathParameters(
                    parameterWithName("year").description("조회할 연도"),
                ),
                responseFields(
                    *responseArrayCommonFields(),  // status, meta, data(array) 공통 필드
                    *fields(
                        "data[].id" type NUMBER means "공휴일 ID",
                        "data[].date" type DATE means "공휴일 날짜",
                        "data[].name" type STRING means "공휴일 이름",
                    )
                )
            )
        )
}
----

=== 전략 2: Subsection - 복잡한 응답을 논리적으로 분리

복잡한 응답을 여러 문서로 나누는 방식입니다. `response-fields.adoc`과 `response-fields-data.adoc`으로 분리됩니다.

==== 사용 시나리오

* 응답 필드가 매우 많은 경우
* 중첩된 객체가 많은 경우
* API 문서를 읽기 쉽게 정리하고 싶은 경우
* 데이터 필드와 메타정보를 명확히 분리하고 싶은 경우

==== 객체 응답 예시

[source,kotlin]
----
@Test
fun `create holiday`(): Unit {
    // given
    val holiday = Holiday(1L, LocalDate.of(2026, 1, 1), "신정")
    given(holidayService.create(any())).willReturn(holiday)

    val request = """
        {
            "holidayDate": "2026-01-01",
            "name": "신정"
        }
    """.trimIndent()

    // when & then
    mockMvc.perform(
        post("/api/holidays")
            .contentType(MediaType.APPLICATION_JSON)
            .content(request)
    )
        .andExpect(status().isOk)
        .andDo(
            restDocs.document(
                requestFields(
                    *fields(
                        "holidayDate" type DATE means "공휴일 날짜",
                        "name" type STRING means "공휴일 이름",
                    )
                ),
                responseFields(*responseCommonFieldsSubsection()),  // status, meta만 포함
                dataResponseFields(  // data 필드는 별도 문서화
                    "id" type NUMBER means "공휴일 ID",
                    "holidayDate" type DATE means "공휴일 날짜",
                    "name" type STRING means "공휴일 이름",
                )
            )
        )
}
----

생성된 문서:
* `response-fields.adoc` - status, meta 필드만 포함
* `response-fields-data.adoc` - data 내부 필드 포함

==== 배열 응답 예시

[source,kotlin]
----
@Test
fun `create holidays bulk`(): Unit {
    // given
    val holidays = listOf(
        Holiday(1L, LocalDate.of(2026, 2, 16), "설날"),
        Holiday(2L, LocalDate.of(2026, 2, 17), "설날"),
    )
    given(holidayService.createAll(any())).willReturn(holidays)

    val request = """
        {
            "holidays": [
                { "holidayDate": "2026-02-16", "name": "설날" },
                { "holidayDate": "2026-02-17", "name": "설날" }
            ]
        }
    """.trimIndent()

    // when & then
    mockMvc.perform(
        post("/api/holidays/bulk")
            .contentType(MediaType.APPLICATION_JSON)
            .content(request)
    )
        .andExpect(status().isOk)
        .andDo(
            restDocs.document(
                requestFields(
                    *fields(
                        "holidays" type ARRAY means "생성할 공휴일 목록",
                        "holidays[].holidayDate" type DATE means "공휴일 날짜",
                        "holidays[].name" type STRING means "공휴일 이름",
                    )
                ),
                responseFields(*responseArrayCommonFieldsSubsection()),  // status, meta[]만 포함
                dataResponseFields(  // data[] 필드는 별도 문서화
                    "id" type NUMBER means "공휴일 ID",
                    "holidayDate" type DATE means "공휴일 날짜",
                    "name" type STRING means "공휴일 이름",
                )
            )
        )
}
----

=== 삭제/빈 응답 처리

DELETE 또는 void 작업의 경우 `responseStringCommonFields()`를 사용합니다.

[source,kotlin]
----
@Test
fun `delete holiday`(): Unit {
    // given
    doNothing().`when`(holidayService).delete(any())

    // when & then
    mockMvc.perform(delete("/api/holidays/{id}", 1L))
        .andExpect(status().isOk)
        .andDo(
            restDocs.document(
                pathParameters(
                    parameterWithName("id").description("삭제할 공휴일 ID"),
                ),
                responseFields(*responseStringCommonFields()),  // status, meta, data(string)
            )
        )
}
----

응답 구조:
[source,json]
----
{
  "status": { "status": 200, "code": "SUCCESS", "message": "..." },
  "meta": { "x-b3-traceid": "...", "appTraceId": "...", "responseTs": ... },
  "data": "SUCCESS"
}
----

== 샘플 코드: HolidayControllerDocsTest 분석

프로젝트의 실제 구현 예시인 `HolidayControllerDocsTest`를 분석합니다.

=== 테스트 클래스 구조

[source,kotlin]
----
class HolidayControllerDocsTest : RestDocsSupport() {

    private val holidayService: HolidayService = mock()

    override fun initController(): Any = HolidayController(holidayService)

    // 각 엔드포인트별 테스트 메서드...
}
----

=== GET - 배열 응답 (Subsection 전략)

[source,kotlin]
----
@Test
fun `get holidays by year`(): Unit {
    // given - 배열 응답 설정
    val holidays = listOf(
        Holiday(1L, LocalDate.of(2026, 2, 16), "설날"),
        Holiday(2L, LocalDate.of(2026, 2, 17), "설날"),
        Holiday(3L, LocalDate.of(2026, 3, 1), "삼일절"),
    )
    given(holidayService.findByYear(2026)).willReturn(holidays)

    // when & then
    mockMvc.perform(get("/api/holidays/{year}", 2026))
        .andExpect(status().isOk)
        .andDo(
            restDocs.document(
                // 경로 파라미터 문서화
                pathParameters(
                    parameterWithName("year").description("조회할 연도"),
                ),
                // Subsection 전략: status/meta 필드 정의
                responseFields(*responseCommonFieldsSubsection()),
                // data 필드 별도 정의
                dataResponseFields(
                    "holidays" type ARRAY means "공휴일 목록",
                    "holidays[].date" type DATE means "공휴일 날짜",
                    "holidays[].name" type STRING means "공휴일 이름",
                ),
            )
        )
}
----

생성된 스니펫:
* `get-holidays-by-year/response-fields.adoc` - status, meta 필드
* `get-holidays-by-year/response-fields-data.adoc` - data 필드

=== POST - 단일 객체 응답 (Subsection 전략)

[source,kotlin]
----
@Test
fun `create holiday`(): Unit {
    // given - 단일 객체 응답 설정
    val holiday = Holiday(1L, LocalDate.of(2026, 1, 1), "신정")
    given(holidayService.create(any())).willReturn(holiday)

    val request = """
        {
            "holidayDate": "2026-01-01",
            "name": "신정"
        }
    """.trimIndent()

    // when & then
    mockMvc.perform(
        post("/api/holidays")
            .contentType(MediaType.APPLICATION_JSON)
            .content(request)
    )
        .andExpect(status().isOk)
        .andDo(
            restDocs.document(
                // 요청 필드 문서화
                requestFields(
                    *fields(
                        "holidayDate" type DATE means "공휴일 날짜",
                        "name" type STRING means "공휴일 이름",
                    )
                ),
                // Subsection 전략: status/meta 필드 정의
                responseFields(*responseCommonFieldsSubsection()),
                // data 필드 별도 정의 (단일 객체)
                dataResponseFields(
                    "id" type NUMBER means "공휴일 ID",
                    "holidayDate" type DATE means "공휴일 날짜",
                    "name" type STRING means "공휴일 이름",
                ),
            )
        )
}
----

주요 특징:
* `requestFields` - 요청 필드 문서화
* `responseCommonFieldsSubsection()` - 공통 필드
* `dataResponseFields()` - 데이터 필드 (경로 접두사 "data." 자동 추가 안함)

=== POST - 배열 응답 (Subsection 전략)

[source,kotlin]
----
@Test
fun `create holidays bulk`(): Unit {
    // given - 배열 응답 설정
    val holidays = listOf(
        Holiday(1L, LocalDate.of(2026, 2, 16), "설날"),
        Holiday(2L, LocalDate.of(2026, 2, 17), "설날"),
    )
    given(holidayService.createAll(any())).willReturn(holidays)

    val request = """
        {
            "holidays": [
                { "holidayDate": "2026-02-16", "name": "설날" },
                { "holidayDate": "2026-02-17", "name": "설날" }
            ]
        }
    """.trimIndent()

    // when & then
    mockMvc.perform(
        post("/api/holidays/bulk")
            .contentType(MediaType.APPLICATION_JSON)
            .content(request)
    )
        .andExpect(status().isOk)
        .andDo(
            restDocs.document(
                requestFields(
                    *fields(
                        "holidays" type ARRAY means "생성할 공휴일 목록",
                        "holidays[].holidayDate" type DATE means "공휴일 날짜",
                        "holidays[].name" type STRING means "공휴일 이름",
                    )
                ),
                // Subsection 전략: status/meta/data[] 필드 정의
                responseFields(*responseArrayCommonFieldsSubsection()),
                // data[] 내부 필드 정의
                dataResponseFields(
                    "id" type NUMBER means "공휴일 ID",
                    "holidayDate" type DATE means "공휴일 날짜",
                    "name" type STRING means "공휴일 이름",
                ),
            )
        )
}
----

주요 차이점:
* `responseArrayCommonFieldsSubsection()` - 배열 응답용 (data[])
* dataResponseFields의 필드는 배열 요소의 필드

=== PUT - 업데이트 응답

[source,kotlin]
----
@Test
fun `update holiday`(): Unit {
    // given
    val holiday = Holiday(1L, LocalDate.of(2026, 2, 16), "설날 (수정)")
    given(holidayService.update(any(), any())).willReturn(holiday)

    val request = """
        {
            "holidayDate": "2026-02-16",
            "name": "설날 (수정)"
        }
    """.trimIndent()

    // when & then
    mockMvc.perform(
        put("/api/holidays/{id}", 1L)
            .contentType(MediaType.APPLICATION_JSON)
            .content(request)
    )
        .andExpect(status().isOk)
        .andDo(
            restDocs.document(
                pathParameters(
                    parameterWithName("id").description("수정할 공휴일 ID"),
                ),
                requestFields(
                    *fields(
                        "holidayDate" type DATE means "공휴일 날짜",
                        "name" type STRING means "공휴일 이름",
                    )
                ),
                responseFields(*responseCommonFieldsSubsection()),
                dataResponseFields(
                    "id" type NUMBER means "공휴일 ID",
                    "holidayDate" type DATE means "공휴일 날짜",
                    "name" type STRING means "공휴일 이름",
                ),
            )
        )
}
----

=== DELETE - 빈 응답

[source,kotlin]
----
@Test
fun `delete holiday`(): Unit {
    // given
    doNothing().`when`(holidayService).delete(any())

    // when & then
    mockMvc.perform(delete("/api/holidays/{id}", 1L))
        .andExpect(status().isOk)
        .andDo(
            restDocs.document(
                pathParameters(
                    parameterWithName("id").description("삭제할 공휴일 ID"),
                ),
                // 빈 응답: responseStringCommonFields 사용
                responseFields(*responseStringCommonFields()),
            )
        )
}
----

== AsciiDoc 문서 작성

REST Docs 테스트에서 생성된 스니펫을 활용하여 API 문서를 작성합니다.

=== 생성된 스니펫 위치

[source,text]
----
build/generated-snippets/
└── {test-class-name}/
    └── {method-name}/
        ├── response-fields.adoc
        ├── response-fields-data.adoc
        ├── request-fields.adoc
        ├── path-parameters.adoc
        └── ...
----

예시: `HolidayControllerDocsTest`의 테스트가 생성하는 스니펫

[source,text]
----
build/generated-snippets/
├── get-holidays-by-year/
│   ├── path-parameters.adoc
│   ├── response-fields.adoc
│   └── response-fields-data.adoc
├── create-holiday/
│   ├── request-fields.adoc
│   ├── response-fields.adoc
│   └── response-fields-data.adoc
└── delete-holiday/
    ├── path-parameters.adoc
    └── response-fields.adoc
----

=== 스니펫 포함 문법

AsciiDoc 문서에서 생성된 스니펫을 포함합니다.

==== 경로 파라미터

[source,asciidoc]
----
== 요청 파라미터

include::{generated-snippets}/get-holidays-by-year/path-parameters.adoc[]
----

==== 요청 필드

[source,asciidoc]
----
== 요청 본문

include::{generated-snippets}/create-holiday/request-fields.adoc[]
----

==== 응답 필드 (Subsection 전략)

[source,asciidoc]
----
== 응답 본문

include::{generated-snippets}/create-holiday/response-fields.adoc[]

=== 데이터 필드

include::{generated-snippets}/create-holiday/response-fields-data.adoc[]
----

==== 응답 필드 (전체 필드)

[source,asciidoc]
----
== 응답 본문

include::{generated-snippets}/get-holidays-by-year/response-fields.adoc[]
----

=== 예시: 완성된 API 문서

[source,asciidoc]
----
== 공휴일 조회 (연도별)

특정 연도의 모든 공휴일을 조회합니다.

=== HTTP 요청

[source,http]
----
GET /api/holidays/2026 HTTP/1.1
Host: localhost:8080
----

=== 경로 파라미터

include::{generated-snippets}/get-holidays-by-year/path-parameters.adoc[]

=== 응답 본문

include::{generated-snippets}/get-holidays-by-year/response-fields.adoc[]

==== 데이터 필드

include::{generated-snippets}/get-holidays-by-year/response-fields-data.adoc[]

=== 응답 예시

[source,json]
----
{
  "status": {
    "status": 200,
    "code": "SUCCESS",
    "message": "Operation successful"
  },
  "meta": {
    "x-b3-traceid": "...",
    "appTraceId": "01946a2c-5b1e-7a00-8e47-0242ac110002",
    "responseTs": 1738473600000,
    "size": 3
  },
  "data": {
    "holidays": [
      { "date": "2026-02-16", "name": "설날" },
      { "date": "2026-02-17", "name": "설날" },
      { "date": "2026-03-01", "name": "삼일절" }
    ]
  }
}
----
----

== Best Practices

=== 1. 테스트 메서드 네이밍

명확한 영문 snake_case 네이밍으로 생성되는 스니펫 디렉토리 이름이 의미 있도록 합니다.

[source,kotlin]
----
// Good: 생성되는 스니펫 디렉토리 = get-holidays-by-year
@Test
fun `get holidays by year`(): Unit { }

// Bad: 생성되는 스니펫 디렉토리 = should-return-holidays
@Test
fun `should return holidays`(): Unit { }
----

=== 2. 필드 설명은 한글로 작성

[source,kotlin]
----
// Good: 명확한 한글 설명
"data.name" type STRING means "공휴일 이름"
"data.date" type DATE means "공휴일 날짜"

// Avoid: 영문 또는 불명확한 설명
"data.name" type STRING means "holiday name"
"data.date" type DATE means "date"
----

=== 3. 복잡한 응답은 Subsection 전략 사용

[source,kotlin]
----
// 배열 응답이나 필드가 많은 경우
responseFields(*responseCommonFieldsSubsection()),
dataResponseFields(
    "field1" type STRING means "설명",
    "field2" type NUMBER means "설명",
)

// 단순한 응답만 전체 필드 한 곳에 정의
responseFields(
    *responseCommonFields(),
    *fields(...)
)
----

=== 4. 샘플 값과 기본값 활용

[source,kotlin]
----
// example과 withDefaultValue 구분
"data.status" type STRING means "상태"
    example "ACTIVE"
    withDefaultValue "PENDING"

// isOptional로 선택 필드 표시
"data.description" type STRING means "설명" isOptional true
----

=== 5. 열거형 타입 활용

[source,kotlin]
----
// ENUM 타입으로 자동 포맷 적용
"data.status" type ENUM(OrderStatus::class) means "주문 상태"
// 출력: `PENDING` / `PROCESSING` / `COMPLETED` / `CANCELLED`

// 특정 값만
"data.priority" type ENUM(listOf(Priority.HIGH, Priority.MEDIUM)) means "우선순위"
----

=== 6. 날짜/시간 타입 자동 포맷

[source,kotlin]
----
// DATE 타입 - 자동으로 yyyy-MM-dd 포맷
"data.birthday" type DATE means "생년월일"

// DATETIME 타입 - 자동으로 yyyy-MM-dd'T'HH:mm:ss 포맷
"data.createdAt" type DATETIME means "생성 일시"

// 커스텀 포맷이 필요한 경우
"data.timestamp" type NUMBER means "타임스탬프" example "1738473600000"
----

=== 7. 배열 필드명 명확하게

[source,kotlin]
----
// Good: 복수형으로 명확하게
"data.holidays" type ARRAY means "공휴일 목록"
"data.holidays[].name" type STRING means "공휴일 이름"

// Less clear: 단수형
"data.holiday" type ARRAY means "공휴일 목록"
----

=== 8. 모킹된 데이터와 스니펫의 일관성

테스트에서 사용하는 모의 데이터가 실제 응답과 일치하도록 합니다.

[source,kotlin]
----
// given - 모의 데이터
val holiday = Holiday(1L, LocalDate.of(2026, 1, 1), "신정")
given(holidayService.create(any())).willReturn(holiday)

// 문서화 - 모의 데이터와 일치
dataResponseFields(
    "id" type NUMBER means "공휴일 ID",
    "holidayDate" type DATE means "공휴일 날짜",  // LocalDate.of 사용했으므로 DATE
    "name" type STRING means "공휴일 이름",
)
----

=== 9. 테스트는 행복한 경로(Happy Path)만 문서화

[source,kotlin]
----
// Good: 성공 케이스만 문서화
@Test
fun `create holiday`(): Unit {
    val holiday = Holiday(1L, LocalDate.of(2026, 1, 1), "신정")
    given(holidayService.create(any())).willReturn(holiday)
    mockMvc.perform(post("/api/holidays")...)
}

// 에러 응답은 별도 문서나 설명으로 처리
----

=== 10. 필드 경로는 정확하게

[source,kotlin]
----
// responseCommonFields() 사용 시 - 전체 경로 명시
responseFields(
    *responseCommonFields(),
    *fields(
        "data.id" type NUMBER means "ID",        // "data." 접두사 필요
        "data.name" type STRING means "이름",
    )
)

// dataResponseFields() 사용 시 - "data." 접두사 제외
dataResponseFields(
    "id" type NUMBER means "ID",               // "data." 접두사 없음
    "name" type STRING means "이름",
)
----

=== 11. 공통 응답 필드는 수정하지 않기

[source,kotlin]
----
// Good: RestDocsSupport의 메서드 그대로 사용
responseFields(*responseCommonFieldsSubsection())

// Bad: 임의로 수정
responseFields(
    "status" type OBJECT means "커스텀 설명",  // 표준 필드 변경 금지
)
----

=== 12. 빌드 과정에서 스니펫 생성 확인

테스트 실행 후 스니펫이 정상 생성되는지 확인합니다.

[source,bash]
----
# 테스트 실행
./gradlew test

# 생성된 스니펫 확인
ls build/generated-snippets/

# 특정 테스트의 스니펫 확인
cat build/generated-snippets/create-holiday/response-fields.adoc
----

== 트러블슈팅

=== 문제: "No such file or directory" 에러

**원인**: 스니펫이 생성되지 않음 (테스트 실패)

**해결**:
1. 테스트 실행 확인: `./gradlew test --info`
2. 테스트 실패 여부 확인
3. 모킹 설정 검토

[source,bash]
----
# 특정 테스트만 실행
./gradlew test --tests "HolidayControllerDocsTest.get holidays by year"
----

=== 문제: 필드 타입이 DocumentFormat에 반영 안됨

**원인**: DocsFieldType 사용 안함

**해결**: 항상 infix `type` 함수와 DocsFieldType 사용

[source,kotlin]
----
// Bad: String 타입 직접 사용
"data.name".type(NUMBER) means "이름"

// Good: DocsFieldType 사용
"data.name" type STRING means "이름"
----

=== 문제: AsciiDoc 포함 실패

**원인**: 스니펫 경로가 잘못됨

**해결**: 실제 디렉토리 이름 확인

[source,bash]
----
# 정확한 스니펫 경로 확인
find build/generated-snippets -name "*.adoc"

# 테스트 메서드명이 스니펫 디렉토리명 결정
@Test
fun `create holiday`(): Unit  // → create-holiday 디렉토리
----

== 추가 자료

* xref:../architecture/07-api-response-format.adoc[API 응답 형식] - ApiResource 구조
* xref:../architecture/03-error-handling.adoc[에러 처리] - 예외 처리 전략
* link:../../modules/test-support/README.adoc[Test Support 모듈] - 추가 유틸
* link:../../modules/bootstrap/common-api-app[Common API App] - 실제 사용 예시

== 참고 파일

[cols="2,4", options="header"]
|===
| 파일 | 위치

| `RestDocsSupport`
| `modules/test-support/src/testFixtures/kotlin/io/glory/testsupport/restdocs/RestDocsSupport.kt`

| `Field`
| `modules/test-support/src/testFixtures/kotlin/io/glory/testsupport/restdocs/Field.kt`

| `DocsFieldType`
| `modules/test-support/src/testFixtures/kotlin/io/glory/testsupport/restdocs/DocsFieldType.kt`

| `HolidayControllerDocsTest`
| `modules/bootstrap/common-api-app/src/test/kotlin/io/glory/commonapiapp/docs/HolidayControllerDocsTest.kt`

| `CustomResponseFieldsSnippet`
| `modules/test-support/src/testFixtures/kotlin/io/glory/testsupport/restdocs/CustomResponseFieldsSnippet.kt`

| `RestDocsAttributes`
| `modules/test-support/src/testFixtures/kotlin/io/glory/testsupport/restdocs/Field.kt` (동일 파일)
|===

== 요약 체크리스트

DocsTest 작성 시 다음 항목을 확인하세요:

* [ ] `RestDocsSupport` 상속
* [ ] `initController()` 구현
* [ ] MockMvc 요청 수행
* [ ] 경로 파라미터 문서화 (필요시)
* [ ] 요청 필드 문서화 (필요시)
* [ ] 응답 필드 문서화
* [ ] 필드 타입에 `DocsFieldType` 사용
* [ ] 필드 설명은 한글로 작성
* [ ] `type`, `means` infix 함수 사용
* [ ] 선택적 필드는 `isOptional true` 추가
* [ ] 날짜는 `DATE`, 날짜시간은 `DATETIME` 사용
* [ ] 열거형은 `ENUM(Class::class)` 사용
* [ ] 테스트 메서드명은 명확한 영문 snake_case
* [ ] 모의 데이터와 문서화 필드 일치
* [ ] 테스트 실행 후 스니펫 생성 확인
* [ ] AsciiDoc 문서에 스니펫 포함

---

**최종 업데이트**: 2026-02-06
